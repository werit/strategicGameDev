//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.2.2-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\ANTLR\Grammars\GStrat.g4 by ANTLR 4.2.2-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace EnvironmentCreator.Gammars {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.2.2-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class GStratParser : Parser {
	public const int
		T__20=1, T__19=2, T__18=3, T__17=4, T__16=5, T__15=6, T__14=7, T__13=8, 
		T__12=9, T__11=10, T__10=11, T__9=12, T__8=13, T__7=14, T__6=15, T__5=16, 
		T__4=17, T__3=18, T__2=19, T__1=20, T__0=21, OPERATOR_COMPARE=22, OPERATOR_ASSIGN=23, 
		ID=24, INT=25;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'effs'", "')'", "'pre'", "','", "'+'", "'*'", "'-'", "'('", 
		"'='", "';'", "'number'", "'action'", "'{'", "'duration'", "'type'", "'extends'", 
		"'effe'", "'instance'", "'/'", "'boolean'", "'}'", "OPERATOR_COMPARE", 
		"OPERATOR_ASSIGN", "ID", "INT"
	};
	public const int
		RULE_root = 0, RULE_type = 1, RULE_variable = 2, RULE_instance = 3, RULE_action = 4, 
		RULE_precondition = 5, RULE_functionCall = 6, RULE_effect = 7, RULE_expression = 8;
	public static readonly string[] ruleNames = {
		"root", "type", "variable", "instance", "action", "precondition", "functionCall", 
		"effect", "expression"
	};

	public override string GrammarFileName { get { return "GStrat.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GStratParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class RootContext : ParserRuleContext {
		public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		public IReadOnlyList<TypeContext> type() {
			return GetRuleContexts<TypeContext>();
		}
		public IReadOnlyList<ActionContext> action() {
			return GetRuleContexts<ActionContext>();
		}
		public InstanceContext instance(int i) {
			return GetRuleContext<InstanceContext>(i);
		}
		public IReadOnlyList<InstanceContext> instance() {
			return GetRuleContexts<InstanceContext>();
		}
		public ActionContext action(int i) {
			return GetRuleContext<ActionContext>(i);
		}
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_root; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterRoot(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitRoot(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoot(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_root);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 23;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << 12) | (1L << 15) | (1L << 18))) != 0)) {
				{
				State = 21;
				switch (_input.La(1)) {
				case 15:
					{
					State = 18; type();
					}
					break;
				case 18:
					{
					State = 19; instance();
					}
					break;
				case 12:
					{
					State = 20; action();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 25;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> ID() { return GetTokens(GStratParser.ID); }
		public IReadOnlyList<VariableContext> variable() {
			return GetRuleContexts<VariableContext>();
		}
		public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		public ITerminalNode ID(int i) {
			return GetToken(GStratParser.ID, i);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_type; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 26; Match(15);
			State = 27; Match(ID);
			{
			State = 28; Match(16);
			State = 29; Match(ID);
			}
			State = 31; Match(13);
			State = 35;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==11 || _la==20) {
				{
				{
				State = 32; variable();
				}
				}
				State = 37;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 38; Match(21);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(GStratParser.ID, 0); }
		public VariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_variable; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable() {
		VariableContext _localctx = new VariableContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_variable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40;
			_la = _input.La(1);
			if ( !(_la==11 || _la==20) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 41; Match(ID);
			State = 42; Match(10);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstanceContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> ID() { return GetTokens(GStratParser.ID); }
		public ITerminalNode ID(int i) {
			return GetToken(GStratParser.ID, i);
		}
		public InstanceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_instance; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterInstance(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitInstance(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstance(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstanceContext instance() {
		InstanceContext _localctx = new InstanceContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_instance);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 44; Match(18);
			State = 45; Match(ID);
			State = 46; Match(ID);
			State = 49;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 47; Match(4);
				State = 48; Match(ID);
				}
				}
				State = 51;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==4 );
			State = 53; Match(10);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ActionContext : ParserRuleContext {
		public PreconditionContext precondition(int i) {
			return GetRuleContext<PreconditionContext>(i);
		}
		public IReadOnlyList<EffectContext> effect() {
			return GetRuleContexts<EffectContext>();
		}
		public IReadOnlyList<ITerminalNode> ID() { return GetTokens(GStratParser.ID); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EffectContext effect(int i) {
			return GetRuleContext<EffectContext>(i);
		}
		public IReadOnlyList<PreconditionContext> precondition() {
			return GetRuleContexts<PreconditionContext>();
		}
		public ITerminalNode ID(int i) {
			return GetToken(GStratParser.ID, i);
		}
		public ActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_action; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterAction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitAction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ActionContext action() {
		ActionContext _localctx = new ActionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_action);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 55; Match(12);
			State = 56; Match(ID);
			State = 57; Match(8);
			State = 60;
			_la = _input.La(1);
			if (_la==ID) {
				{
				State = 58; Match(ID);
				State = 59; Match(ID);
				}
			}

			{
			State = 62; Match(4);
			State = 63; Match(ID);
			State = 64; Match(ID);
			}
			State = 66; Match(2);
			State = 67; Match(14);
			State = 68; Match(9);
			State = 69; expression(0);
			State = 70; Match(3);
			State = 71; Match(13);
			State = 75;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ID) {
				{
				{
				State = 72; precondition();
				}
				}
				State = 77;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 78; Match(21);
			State = 79; Match(1);
			State = 80; Match(13);
			State = 84;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ID) {
				{
				{
				State = 81; effect();
				}
				}
				State = 86;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 87; Match(21);
			State = 88; Match(17);
			State = 89; Match(13);
			State = 93;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ID) {
				{
				{
				State = 90; effect();
				}
				}
				State = 95;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 96; Match(21);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PreconditionContext : ParserRuleContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public ITerminalNode ID() { return GetToken(GStratParser.ID, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode OPERATOR_COMPARE() { return GetToken(GStratParser.OPERATOR_COMPARE, 0); }
		public PreconditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_precondition; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterPrecondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitPrecondition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PreconditionContext precondition() {
		PreconditionContext _localctx = new PreconditionContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_precondition);
		try {
			State = 102;
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 98; Match(ID);
				State = 99; Match(OPERATOR_COMPARE);
				State = 100; expression(0);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 101; functionCall();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> INT() { return GetTokens(GStratParser.INT); }
		public IReadOnlyList<ITerminalNode> ID() { return GetTokens(GStratParser.ID); }
		public ITerminalNode INT(int i) {
			return GetToken(GStratParser.INT, i);
		}
		public ITerminalNode ID(int i) {
			return GetToken(GStratParser.ID, i);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_functionCall; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 104; Match(ID);
			State = 105; Match(8);
			State = 107;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				{
				State = 106;
				_la = _input.La(1);
				if ( !(_la==ID || _la==INT) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 114;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==4 || _la==INT) {
				{
				State = 112;
				switch (_input.La(1)) {
				case 4:
					{
					State = 109; Match(4);
					State = 110; Match(ID);
					}
					break;
				case INT:
					{
					State = 111; Match(INT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 116;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 117; Match(2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EffectContext : ParserRuleContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public ITerminalNode OPERATOR_ASSIGN() { return GetToken(GStratParser.OPERATOR_ASSIGN, 0); }
		public ITerminalNode ID() { return GetToken(GStratParser.ID, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public EffectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_effect; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterEffect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitEffect(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEffect(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EffectContext effect() {
		EffectContext _localctx = new EffectContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_effect);
		try {
			State = 125;
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 119; Match(ID);
				State = 120; Match(OPERATOR_ASSIGN);
				State = 121; expression(0);
				State = 122; Match(10);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 124; functionCall();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode INT() { return GetToken(GStratParser.INT, 0); }
		public ITerminalNode ID() { return GetToken(GStratParser.ID, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int GetRuleIndex() { return RULE_expression; }
		public override void EnterRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGStratListener typedListener = listener as IGStratListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGStratVisitor<TResult> typedVisitor = visitor as IGStratVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 16;
		EnterRecursionRule(_localctx, 16, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 134;
			switch (_input.La(1)) {
			case ID:
				{
				State = 128; Match(ID);
				}
				break;
			case INT:
				{
				State = 129; Match(INT);
				}
				break;
			case 8:
				{
				State = 130; Match(8);
				State = 131; expression(0);
				State = 132; Match(2);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 141;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,14,_ctx);
			while ( _alt!=2 && _alt!=ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_expression);
					State = 136;
					if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
					State = 137;
					_la = _input.La(1);
					if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << 5) | (1L << 6) | (1L << 7) | (1L << 19))) != 0)) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					State = 138; expression(5);
					}
					} 
				}
				State = 143;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,14,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 8: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 4);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x1B\x93\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x3\x2\x3\x2\x3\x2\a\x2\x18\n\x2\f\x2\xE\x2\x1B\v\x2\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3$\n\x3\f\x3\xE\x3\'\v\x3\x3\x3"+
		"\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x6\x5\x34"+
		"\n\x5\r\x5\xE\x5\x35\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6?"+
		"\n\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\a\x6L\n\x6\f\x6\xE\x6O\v\x6\x3\x6\x3\x6\x3\x6\x3\x6\a\x6U\n\x6\f\x6\xE"+
		"\x6X\v\x6\x3\x6\x3\x6\x3\x6\x3\x6\a\x6^\n\x6\f\x6\xE\x6\x61\v\x6\x3\x6"+
		"\x3\x6\x3\a\x3\a\x3\a\x3\a\x5\ai\n\a\x3\b\x3\b\x3\b\x5\bn\n\b\x3\b\x3"+
		"\b\x3\b\a\bs\n\b\f\b\xE\bv\v\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t"+
		"\x5\t\x80\n\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x5\n\x89\n\n\x3\n\x3"+
		"\n\x3\n\a\n\x8E\n\n\f\n\xE\n\x91\v\n\x3\n\x2\x2\x3\x12\v\x2\x2\x4\x2\x6"+
		"\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x2\x5\x4\x2\r\r\x16\x16\x3\x2\x1A"+
		"\x1B\x4\x2\a\t\x15\x15\x9A\x2\x19\x3\x2\x2\x2\x4\x1C\x3\x2\x2\x2\x6*\x3"+
		"\x2\x2\x2\b.\x3\x2\x2\x2\n\x39\x3\x2\x2\x2\fh\x3\x2\x2\x2\xEj\x3\x2\x2"+
		"\x2\x10\x7F\x3\x2\x2\x2\x12\x88\x3\x2\x2\x2\x14\x18\x5\x4\x3\x2\x15\x18"+
		"\x5\b\x5\x2\x16\x18\x5\n\x6\x2\x17\x14\x3\x2\x2\x2\x17\x15\x3\x2\x2\x2"+
		"\x17\x16\x3\x2\x2\x2\x18\x1B\x3\x2\x2\x2\x19\x17\x3\x2\x2\x2\x19\x1A\x3"+
		"\x2\x2\x2\x1A\x3\x3\x2\x2\x2\x1B\x19\x3\x2\x2\x2\x1C\x1D\a\x11\x2\x2\x1D"+
		"\x1E\a\x1A\x2\x2\x1E\x1F\a\x12\x2\x2\x1F \a\x1A\x2\x2 !\x3\x2\x2\x2!%"+
		"\a\xF\x2\x2\"$\x5\x6\x4\x2#\"\x3\x2\x2\x2$\'\x3\x2\x2\x2%#\x3\x2\x2\x2"+
		"%&\x3\x2\x2\x2&(\x3\x2\x2\x2\'%\x3\x2\x2\x2()\a\x17\x2\x2)\x5\x3\x2\x2"+
		"\x2*+\t\x2\x2\x2+,\a\x1A\x2\x2,-\a\f\x2\x2-\a\x3\x2\x2\x2./\a\x14\x2\x2"+
		"/\x30\a\x1A\x2\x2\x30\x33\a\x1A\x2\x2\x31\x32\a\x6\x2\x2\x32\x34\a\x1A"+
		"\x2\x2\x33\x31\x3\x2\x2\x2\x34\x35\x3\x2\x2\x2\x35\x33\x3\x2\x2\x2\x35"+
		"\x36\x3\x2\x2\x2\x36\x37\x3\x2\x2\x2\x37\x38\a\f\x2\x2\x38\t\x3\x2\x2"+
		"\x2\x39:\a\xE\x2\x2:;\a\x1A\x2\x2;>\a\n\x2\x2<=\a\x1A\x2\x2=?\a\x1A\x2"+
		"\x2><\x3\x2\x2\x2>?\x3\x2\x2\x2?@\x3\x2\x2\x2@\x41\a\x6\x2\x2\x41\x42"+
		"\a\x1A\x2\x2\x42\x43\a\x1A\x2\x2\x43\x44\x3\x2\x2\x2\x44\x45\a\x4\x2\x2"+
		"\x45\x46\a\x10\x2\x2\x46G\a\v\x2\x2GH\x5\x12\n\x2HI\a\x5\x2\x2IM\a\xF"+
		"\x2\x2JL\x5\f\a\x2KJ\x3\x2\x2\x2LO\x3\x2\x2\x2MK\x3\x2\x2\x2MN\x3\x2\x2"+
		"\x2NP\x3\x2\x2\x2OM\x3\x2\x2\x2PQ\a\x17\x2\x2QR\a\x3\x2\x2RV\a\xF\x2\x2"+
		"SU\x5\x10\t\x2TS\x3\x2\x2\x2UX\x3\x2\x2\x2VT\x3\x2\x2\x2VW\x3\x2\x2\x2"+
		"WY\x3\x2\x2\x2XV\x3\x2\x2\x2YZ\a\x17\x2\x2Z[\a\x13\x2\x2[_\a\xF\x2\x2"+
		"\\^\x5\x10\t\x2]\\\x3\x2\x2\x2^\x61\x3\x2\x2\x2_]\x3\x2\x2\x2_`\x3\x2"+
		"\x2\x2`\x62\x3\x2\x2\x2\x61_\x3\x2\x2\x2\x62\x63\a\x17\x2\x2\x63\v\x3"+
		"\x2\x2\x2\x64\x65\a\x1A\x2\x2\x65\x66\a\x18\x2\x2\x66i\x5\x12\n\x2gi\x5"+
		"\xE\b\x2h\x64\x3\x2\x2\x2hg\x3\x2\x2\x2i\r\x3\x2\x2\x2jk\a\x1A\x2\x2k"+
		"m\a\n\x2\x2ln\t\x3\x2\x2ml\x3\x2\x2\x2mn\x3\x2\x2\x2nt\x3\x2\x2\x2op\a"+
		"\x6\x2\x2ps\a\x1A\x2\x2qs\a\x1B\x2\x2ro\x3\x2\x2\x2rq\x3\x2\x2\x2sv\x3"+
		"\x2\x2\x2tr\x3\x2\x2\x2tu\x3\x2\x2\x2uw\x3\x2\x2\x2vt\x3\x2\x2\x2wx\a"+
		"\x4\x2\x2x\xF\x3\x2\x2\x2yz\a\x1A\x2\x2z{\a\x19\x2\x2{|\x5\x12\n\x2|}"+
		"\a\f\x2\x2}\x80\x3\x2\x2\x2~\x80\x5\xE\b\x2\x7Fy\x3\x2\x2\x2\x7F~\x3\x2"+
		"\x2\x2\x80\x11\x3\x2\x2\x2\x81\x82\b\n\x1\x2\x82\x89\a\x1A\x2\x2\x83\x89"+
		"\a\x1B\x2\x2\x84\x85\a\n\x2\x2\x85\x86\x5\x12\n\x2\x86\x87\a\x4\x2\x2"+
		"\x87\x89\x3\x2\x2\x2\x88\x81\x3\x2\x2\x2\x88\x83\x3\x2\x2\x2\x88\x84\x3"+
		"\x2\x2\x2\x89\x8F\x3\x2\x2\x2\x8A\x8B\f\x6\x2\x2\x8B\x8C\t\x4\x2\x2\x8C"+
		"\x8E\x5\x12\n\a\x8D\x8A\x3\x2\x2\x2\x8E\x91\x3\x2\x2\x2\x8F\x8D\x3\x2"+
		"\x2\x2\x8F\x90\x3\x2\x2\x2\x90\x13\x3\x2\x2\x2\x91\x8F\x3\x2\x2\x2\x11"+
		"\x17\x19%\x35>MV_hmrt\x7F\x88\x8F";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace EnvironmentCreator.Gammars
